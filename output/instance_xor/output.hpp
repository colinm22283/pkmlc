#pragma once
#include <cstdint>
namespace PKML{using float_t=float;}
#include "../include/pkml.hpp"
namespace InstanceXor{namespace _LayerSizes {using l0_size = PKML::Dimension<2>;using l0_1_size = PKML::Dimension<2>;using l1_2_size = PKML::Dimension<2>;using l2_3_size = PKML::Dimension<2>;using l3_4_size = PKML::Dimension<2>;using l4_5_size = PKML::Dimension<2>;using l5_size = PKML::Dimension<2>;}class Dataset;class Network{public:Network();~Network();void train(std::size_t iterations, InstanceXor::Dataset & dataset);void copy_outputs(PKML::float_t * dst);void copy_inputs(PKML::float_t * src);};class Dataset {friend class InstanceXor::Network;public:struct TrainingSet {PKML::float_t inputs[InstanceXor::_LayerSizes::l0_size::element_product];PKML::float_t outputs[InstanceXor::_LayerSizes::l5_size::element_product];};protected:std::size_t _size, _capacity;TrainingSet * _data;public:Dataset();~Dataset();void push_back(const TrainingSet & value);inline void push_back(const TrainingSet && value) { push_back((TrainingSet &) value); }[[nodiscard]] inline std::size_t size() const noexcept { return _size; }[[nodiscard]] inline std::size_t capacity() const noexcept { return _capacity; }};}