#pragma once
#include <cstdint>
namespace PKML{using float_t=float;}
#include <pkml.hpp>
namespace InstanceXor{namespace _LayerSizes {using l0_size = PKML::Dimension<2>;using l0_1_size = PKML::Dimension<4>;using l1_2_size = PKML::Dimension<4>;using l2_3_size = PKML::Dimension<1>;using l3_size = PKML::Dimension<1>;}class Dataset;class Network{public:Network();~Network();void forward();void train(std::size_t iterations, std::size_t mult, InstanceXor::Dataset & dataset);PKML::float_t evaluate(InstanceXor::Dataset & dataset);void save(const char * path);void load(const char * path);void copy_outputs(PKML::float_t * dst);void copy_inputs(PKML::float_t * src);};class Dataset {friend class InstanceXor::Network;public:struct TrainingSet {PKML::float_t inputs[InstanceXor::_LayerSizes::l0_size::element_product];PKML::float_t outputs[InstanceXor::_LayerSizes::l3_size::element_product];};protected:std::size_t _size, _capacity;TrainingSet * _data;public:Dataset();~Dataset();void push_back(const TrainingSet & value);inline void push_back(const TrainingSet && value) { push_back((TrainingSet &) value); }inline void copy_back(PKML::float_t * inputs, PKML::float_t * outputs) {TrainingSet temp;for (std::size_t i = 0; i < InstanceXor::_LayerSizes::l0_size::element_product; i++) temp.inputs[i] = inputs[i];for (std::size_t i = 0; i < InstanceXor::_LayerSizes::l3_size::element_product; i++) temp.outputs[i] = outputs[i];push_back(temp);}void pull_set(std::size_t index, TrainingSet & set) const;[[nodiscard]] inline std::size_t size() const noexcept { return _size; }[[nodiscard]] inline std::size_t capacity() const noexcept { return _capacity; }};}