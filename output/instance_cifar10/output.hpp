#pragma once
#include <cstdint>
namespace PKML{using float_t=float;}
#include <pkml.hpp>
namespace InstanceCifar10{namespace _LayerSizes {using l0_size = PKML::Dimension<32, 32, 3>;using l0_1_size = PKML::Dimension<40, 40>;using l1_2_size = PKML::Dimension<40, 40>;using l2_3_size = PKML::Dimension<40, 40>;using l3_4_size = PKML::Dimension<40, 40>;using l4_5_size = PKML::Dimension<20, 20>;using l5_6_size = PKML::Dimension<20, 20>;using l6_7_size = PKML::Dimension<10>;using l7_size = PKML::Dimension<10>;}class Dataset;class Network{public:Network();~Network();void forward();void train(std::size_t iterations, std::size_t mult, InstanceCifar10::Dataset & dataset);PKML::float_t evaluate(InstanceCifar10::Dataset & dataset);void save(const char * path);void load(const char * path);void copy_outputs(PKML::float_t * dst);void copy_inputs(PKML::float_t * src);};class Dataset {friend class InstanceCifar10::Network;public:struct TrainingSet {PKML::float_t inputs[InstanceCifar10::_LayerSizes::l0_size::element_product];PKML::float_t outputs[InstanceCifar10::_LayerSizes::l7_size::element_product];};protected:std::size_t _size, _capacity;TrainingSet * _data;public:Dataset();~Dataset();void push_back(const TrainingSet & value);inline void push_back(const TrainingSet && value) { push_back((TrainingSet &) value); }inline void copy_back(PKML::float_t * inputs, PKML::float_t * outputs) {TrainingSet temp;for (std::size_t i = 0; i < InstanceCifar10::_LayerSizes::l0_size::element_product; i++) temp.inputs[i] = inputs[i];for (std::size_t i = 0; i < InstanceCifar10::_LayerSizes::l7_size::element_product; i++) temp.outputs[i] = outputs[i];push_back(temp);}void pull_set(std::size_t index, TrainingSet & set) const;[[nodiscard]] inline std::size_t size() const noexcept { return _size; }[[nodiscard]] inline std::size_t capacity() const noexcept { return _capacity; }};}